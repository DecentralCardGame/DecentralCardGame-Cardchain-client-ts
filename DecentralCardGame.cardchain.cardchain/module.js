// Generated by Ignite ignite.com/cli
import { SigningStargateClient } from "@cosmjs/stargate";
import { Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { Api } from "./rest";
import { MsgSetCardRarity } from "./types/cardchain/cardchain/tx";
import { MsgCreateCollection } from "./types/cardchain/cardchain/tx";
import { MsgBuyCollection } from "./types/cardchain/cardchain/tx";
import { MsgBuyCardScheme } from "./types/cardchain/cardchain/tx";
import { MsgCreateSellOffer } from "./types/cardchain/cardchain/tx";
import { MsgSetCollectionArtist } from "./types/cardchain/cardchain/tx";
import { MsgRevealCouncilResponse } from "./types/cardchain/cardchain/tx";
import { MsgDonateToCard } from "./types/cardchain/cardchain/tx";
import { MsgTransferCard } from "./types/cardchain/cardchain/tx";
import { MsgAddContributorToCollection } from "./types/cardchain/cardchain/tx";
import { MsgRegisterForCouncil } from "./types/cardchain/cardchain/tx";
import { MsgCreateCouncil } from "./types/cardchain/cardchain/tx";
import { MsgAddArtworkToCollection } from "./types/cardchain/cardchain/tx";
import { MsgSetUserBiography } from "./types/cardchain/cardchain/tx";
import { MsgRemoveCardFromCollection } from "./types/cardchain/cardchain/tx";
import { MsgVoteCard } from "./types/cardchain/cardchain/tx";
import { MsgCommitCouncilResponse } from "./types/cardchain/cardchain/tx";
import { MsgOpenBoosterPack } from "./types/cardchain/cardchain/tx";
import { MsgSetUserWebsite } from "./types/cardchain/cardchain/tx";
import { MsgSubmitCopyrightProposal } from "./types/cardchain/cardchain/tx";
import { MsgSaveCardContent } from "./types/cardchain/cardchain/tx";
import { MsgRemoveContributorFromCollection } from "./types/cardchain/cardchain/tx";
import { MsgConfirmMatch } from "./types/cardchain/cardchain/tx";
import { MsgRewokeCouncilRegistration } from "./types/cardchain/cardchain/tx";
import { MsgChangeArtist } from "./types/cardchain/cardchain/tx";
import { MsgRemoveSellOffer } from "./types/cardchain/cardchain/tx";
import { MsgAddCardToCollection } from "./types/cardchain/cardchain/tx";
import { MsgFinalizeCollection } from "./types/cardchain/cardchain/tx";
import { MsgAddStoryToCollection } from "./types/cardchain/cardchain/tx";
import { MsgSetCollectionStoryWriter } from "./types/cardchain/cardchain/tx";
import { MsgMultiVoteCard } from "./types/cardchain/cardchain/tx";
import { MsgAddArtwork } from "./types/cardchain/cardchain/tx";
import { MsgReportMatch } from "./types/cardchain/cardchain/tx";
import { MsgCreateuser } from "./types/cardchain/cardchain/tx";
import { MsgSubmitCollectionProposal } from "./types/cardchain/cardchain/tx";
import { MsgRestartCouncil } from "./types/cardchain/cardchain/tx";
import { MsgSubmitMatchReporterProposal } from "./types/cardchain/cardchain/tx";
import { MsgSetProfileCard } from "./types/cardchain/cardchain/tx";
import { MsgApointMatchReporter } from "./types/cardchain/cardchain/tx";
import { MsgBuyCard } from "./types/cardchain/cardchain/tx";
import { MsgTransferBoosterPack } from "./types/cardchain/cardchain/tx";
import { Card as typeCard } from "./types";
import { TimeStamp as typeTimeStamp } from "./types";
import { Collection as typeCollection } from "./types";
import { CollectionProposal as typeCollectionProposal } from "./types";
import { CopyrightProposal as typeCopyrightProposal } from "./types";
import { WrapClearResponse as typeWrapClearResponse } from "./types";
import { WrapHashResponse as typeWrapHashResponse } from "./types";
import { Image as typeImage } from "./types";
import { MatchPlayer as typeMatchPlayer } from "./types";
import { MatchReporterProposal as typeMatchReporterProposal } from "./types";
import { Num as typeNum } from "./types";
import { Params as typeParams } from "./types";
import { IgnoreMatches as typeIgnoreMatches } from "./types";
import { IgnoreSellOffers as typeIgnoreSellOffers } from "./types";
import { QueryQServerResponse as typeQueryQServerResponse } from "./types";
import { RunningAverage as typeRunningAverage } from "./types";
import { SingleVote as typeSingleVote } from "./types";
import { BoosterPack as typeBoosterPack } from "./types";
import { AirDrops as typeAirDrops } from "./types";
import { VoteRight as typeVoteRight } from "./types";
import { VotingResult as typeVotingResult } from "./types";
import { VotingResults as typeVotingResults } from "./types";
export { MsgSetCardRarity, MsgCreateCollection, MsgBuyCollection, MsgBuyCardScheme, MsgCreateSellOffer, MsgSetCollectionArtist, MsgRevealCouncilResponse, MsgDonateToCard, MsgTransferCard, MsgAddContributorToCollection, MsgRegisterForCouncil, MsgCreateCouncil, MsgAddArtworkToCollection, MsgSetUserBiography, MsgRemoveCardFromCollection, MsgVoteCard, MsgCommitCouncilResponse, MsgOpenBoosterPack, MsgSetUserWebsite, MsgSubmitCopyrightProposal, MsgSaveCardContent, MsgRemoveContributorFromCollection, MsgConfirmMatch, MsgRewokeCouncilRegistration, MsgChangeArtist, MsgRemoveSellOffer, MsgAddCardToCollection, MsgFinalizeCollection, MsgAddStoryToCollection, MsgSetCollectionStoryWriter, MsgMultiVoteCard, MsgAddArtwork, MsgReportMatch, MsgCreateuser, MsgSubmitCollectionProposal, MsgRestartCouncil, MsgSubmitMatchReporterProposal, MsgSetProfileCard, MsgApointMatchReporter, MsgBuyCard, MsgTransferBoosterPack };
export const registry = new Registry(msgTypes);
function getStructure(template) {
    const structure = { fields: [] };
    for (let [key, value] of Object.entries(template)) {
        let field = { name: key, type: typeof value };
        structure.fields.push(field);
    }
    return structure;
}
const defaultFee = {
    amount: [],
    gas: "200000",
};
export const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendMsgSetCardRarity({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetCardRarity: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetCardRarity({ value: MsgSetCardRarity.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetCardRarity: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateCollection({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateCollection: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgCreateCollection({ value: MsgCreateCollection.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateCollection: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgBuyCollection({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgBuyCollection: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgBuyCollection({ value: MsgBuyCollection.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgBuyCollection: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgBuyCardScheme({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgBuyCardScheme: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgBuyCardScheme({ value: MsgBuyCardScheme.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgBuyCardScheme: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateSellOffer({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateSellOffer: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgCreateSellOffer({ value: MsgCreateSellOffer.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateSellOffer: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetCollectionArtist({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetCollectionArtist: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetCollectionArtist({ value: MsgSetCollectionArtist.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetCollectionArtist: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRevealCouncilResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRevealCouncilResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRevealCouncilResponse({ value: MsgRevealCouncilResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRevealCouncilResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgDonateToCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgDonateToCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgDonateToCard({ value: MsgDonateToCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgDonateToCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgTransferCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgTransferCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgTransferCard({ value: MsgTransferCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgTransferCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAddContributorToCollection({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAddContributorToCollection: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgAddContributorToCollection({ value: MsgAddContributorToCollection.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAddContributorToCollection: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRegisterForCouncil({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRegisterForCouncil: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRegisterForCouncil({ value: MsgRegisterForCouncil.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRegisterForCouncil: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateCouncil({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateCouncil: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgCreateCouncil({ value: MsgCreateCouncil.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateCouncil: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAddArtworkToCollection({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAddArtworkToCollection: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgAddArtworkToCollection({ value: MsgAddArtworkToCollection.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAddArtworkToCollection: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetUserBiography({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetUserBiography: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetUserBiography({ value: MsgSetUserBiography.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetUserBiography: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRemoveCardFromCollection({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRemoveCardFromCollection: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRemoveCardFromCollection({ value: MsgRemoveCardFromCollection.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRemoveCardFromCollection: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgVoteCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgVoteCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgVoteCard({ value: MsgVoteCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgVoteCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCommitCouncilResponse({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCommitCouncilResponse: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgCommitCouncilResponse({ value: MsgCommitCouncilResponse.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCommitCouncilResponse: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgOpenBoosterPack({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgOpenBoosterPack: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgOpenBoosterPack({ value: MsgOpenBoosterPack.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgOpenBoosterPack: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetUserWebsite({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetUserWebsite: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetUserWebsite({ value: MsgSetUserWebsite.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetUserWebsite: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSubmitCopyrightProposal({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSubmitCopyrightProposal: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSubmitCopyrightProposal({ value: MsgSubmitCopyrightProposal.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSubmitCopyrightProposal: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSaveCardContent({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSaveCardContent: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSaveCardContent({ value: MsgSaveCardContent.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSaveCardContent: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRemoveContributorFromCollection({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRemoveContributorFromCollection: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRemoveContributorFromCollection({ value: MsgRemoveContributorFromCollection.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRemoveContributorFromCollection: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgConfirmMatch({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgConfirmMatch: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgConfirmMatch({ value: MsgConfirmMatch.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgConfirmMatch: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRewokeCouncilRegistration({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRewokeCouncilRegistration: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRewokeCouncilRegistration({ value: MsgRewokeCouncilRegistration.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRewokeCouncilRegistration: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgChangeArtist({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgChangeArtist: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgChangeArtist({ value: MsgChangeArtist.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgChangeArtist: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRemoveSellOffer({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRemoveSellOffer: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRemoveSellOffer({ value: MsgRemoveSellOffer.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRemoveSellOffer: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAddCardToCollection({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAddCardToCollection: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgAddCardToCollection({ value: MsgAddCardToCollection.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAddCardToCollection: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgFinalizeCollection({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgFinalizeCollection: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgFinalizeCollection({ value: MsgFinalizeCollection.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgFinalizeCollection: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAddStoryToCollection({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAddStoryToCollection: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgAddStoryToCollection({ value: MsgAddStoryToCollection.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAddStoryToCollection: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetCollectionStoryWriter({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetCollectionStoryWriter: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetCollectionStoryWriter({ value: MsgSetCollectionStoryWriter.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetCollectionStoryWriter: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgMultiVoteCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgMultiVoteCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgMultiVoteCard({ value: MsgMultiVoteCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgMultiVoteCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgAddArtwork({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgAddArtwork: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgAddArtwork({ value: MsgAddArtwork.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgAddArtwork: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgReportMatch({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgReportMatch: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgReportMatch({ value: MsgReportMatch.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgReportMatch: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateuser({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateuser: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgCreateuser({ value: MsgCreateuser.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateuser: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSubmitCollectionProposal({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSubmitCollectionProposal: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSubmitCollectionProposal({ value: MsgSubmitCollectionProposal.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSubmitCollectionProposal: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgRestartCouncil({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgRestartCouncil: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgRestartCouncil({ value: MsgRestartCouncil.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgRestartCouncil: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSubmitMatchReporterProposal({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSubmitMatchReporterProposal: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSubmitMatchReporterProposal({ value: MsgSubmitMatchReporterProposal.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSubmitMatchReporterProposal: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSetProfileCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSetProfileCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgSetProfileCard({ value: MsgSetProfileCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSetProfileCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgApointMatchReporter({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgApointMatchReporter: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgApointMatchReporter({ value: MsgApointMatchReporter.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgApointMatchReporter: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgBuyCard({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgBuyCard: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgBuyCard({ value: MsgBuyCard.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgBuyCard: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgTransferBoosterPack({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgTransferBoosterPack: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await SigningStargateClient.connectWithSigner(addr, signer, { registry, prefix });
                let msg = this.msgTransferBoosterPack({ value: MsgTransferBoosterPack.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgTransferBoosterPack: Could not broadcast Tx: ' + e.message);
            }
        },
        msgSetCardRarity({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetCardRarity", value: MsgSetCardRarity.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetCardRarity: Could not create message: ' + e.message);
            }
        },
        msgCreateCollection({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgCreateCollection", value: MsgCreateCollection.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateCollection: Could not create message: ' + e.message);
            }
        },
        msgBuyCollection({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgBuyCollection", value: MsgBuyCollection.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgBuyCollection: Could not create message: ' + e.message);
            }
        },
        msgBuyCardScheme({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgBuyCardScheme", value: MsgBuyCardScheme.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgBuyCardScheme: Could not create message: ' + e.message);
            }
        },
        msgCreateSellOffer({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgCreateSellOffer", value: MsgCreateSellOffer.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateSellOffer: Could not create message: ' + e.message);
            }
        },
        msgSetCollectionArtist({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetCollectionArtist", value: MsgSetCollectionArtist.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetCollectionArtist: Could not create message: ' + e.message);
            }
        },
        msgRevealCouncilResponse({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRevealCouncilResponse", value: MsgRevealCouncilResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRevealCouncilResponse: Could not create message: ' + e.message);
            }
        },
        msgDonateToCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgDonateToCard", value: MsgDonateToCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgDonateToCard: Could not create message: ' + e.message);
            }
        },
        msgTransferCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgTransferCard", value: MsgTransferCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgTransferCard: Could not create message: ' + e.message);
            }
        },
        msgAddContributorToCollection({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgAddContributorToCollection", value: MsgAddContributorToCollection.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAddContributorToCollection: Could not create message: ' + e.message);
            }
        },
        msgRegisterForCouncil({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRegisterForCouncil", value: MsgRegisterForCouncil.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRegisterForCouncil: Could not create message: ' + e.message);
            }
        },
        msgCreateCouncil({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgCreateCouncil", value: MsgCreateCouncil.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateCouncil: Could not create message: ' + e.message);
            }
        },
        msgAddArtworkToCollection({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgAddArtworkToCollection", value: MsgAddArtworkToCollection.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAddArtworkToCollection: Could not create message: ' + e.message);
            }
        },
        msgSetUserBiography({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetUserBiography", value: MsgSetUserBiography.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetUserBiography: Could not create message: ' + e.message);
            }
        },
        msgRemoveCardFromCollection({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRemoveCardFromCollection", value: MsgRemoveCardFromCollection.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRemoveCardFromCollection: Could not create message: ' + e.message);
            }
        },
        msgVoteCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgVoteCard", value: MsgVoteCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgVoteCard: Could not create message: ' + e.message);
            }
        },
        msgCommitCouncilResponse({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgCommitCouncilResponse", value: MsgCommitCouncilResponse.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCommitCouncilResponse: Could not create message: ' + e.message);
            }
        },
        msgOpenBoosterPack({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgOpenBoosterPack", value: MsgOpenBoosterPack.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgOpenBoosterPack: Could not create message: ' + e.message);
            }
        },
        msgSetUserWebsite({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetUserWebsite", value: MsgSetUserWebsite.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetUserWebsite: Could not create message: ' + e.message);
            }
        },
        msgSubmitCopyrightProposal({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSubmitCopyrightProposal", value: MsgSubmitCopyrightProposal.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSubmitCopyrightProposal: Could not create message: ' + e.message);
            }
        },
        msgSaveCardContent({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSaveCardContent", value: MsgSaveCardContent.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSaveCardContent: Could not create message: ' + e.message);
            }
        },
        msgRemoveContributorFromCollection({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRemoveContributorFromCollection", value: MsgRemoveContributorFromCollection.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRemoveContributorFromCollection: Could not create message: ' + e.message);
            }
        },
        msgConfirmMatch({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgConfirmMatch", value: MsgConfirmMatch.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgConfirmMatch: Could not create message: ' + e.message);
            }
        },
        msgRewokeCouncilRegistration({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRewokeCouncilRegistration", value: MsgRewokeCouncilRegistration.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRewokeCouncilRegistration: Could not create message: ' + e.message);
            }
        },
        msgChangeArtist({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgChangeArtist", value: MsgChangeArtist.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgChangeArtist: Could not create message: ' + e.message);
            }
        },
        msgRemoveSellOffer({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRemoveSellOffer", value: MsgRemoveSellOffer.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRemoveSellOffer: Could not create message: ' + e.message);
            }
        },
        msgAddCardToCollection({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgAddCardToCollection", value: MsgAddCardToCollection.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAddCardToCollection: Could not create message: ' + e.message);
            }
        },
        msgFinalizeCollection({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgFinalizeCollection", value: MsgFinalizeCollection.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgFinalizeCollection: Could not create message: ' + e.message);
            }
        },
        msgAddStoryToCollection({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgAddStoryToCollection", value: MsgAddStoryToCollection.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAddStoryToCollection: Could not create message: ' + e.message);
            }
        },
        msgSetCollectionStoryWriter({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetCollectionStoryWriter", value: MsgSetCollectionStoryWriter.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetCollectionStoryWriter: Could not create message: ' + e.message);
            }
        },
        msgMultiVoteCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgMultiVoteCard", value: MsgMultiVoteCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgMultiVoteCard: Could not create message: ' + e.message);
            }
        },
        msgAddArtwork({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgAddArtwork", value: MsgAddArtwork.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgAddArtwork: Could not create message: ' + e.message);
            }
        },
        msgReportMatch({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgReportMatch", value: MsgReportMatch.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgReportMatch: Could not create message: ' + e.message);
            }
        },
        msgCreateuser({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgCreateuser", value: MsgCreateuser.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateuser: Could not create message: ' + e.message);
            }
        },
        msgSubmitCollectionProposal({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSubmitCollectionProposal", value: MsgSubmitCollectionProposal.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSubmitCollectionProposal: Could not create message: ' + e.message);
            }
        },
        msgRestartCouncil({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgRestartCouncil", value: MsgRestartCouncil.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgRestartCouncil: Could not create message: ' + e.message);
            }
        },
        msgSubmitMatchReporterProposal({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSubmitMatchReporterProposal", value: MsgSubmitMatchReporterProposal.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSubmitMatchReporterProposal: Could not create message: ' + e.message);
            }
        },
        msgSetProfileCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgSetProfileCard", value: MsgSetProfileCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSetProfileCard: Could not create message: ' + e.message);
            }
        },
        msgApointMatchReporter({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgApointMatchReporter", value: MsgApointMatchReporter.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgApointMatchReporter: Could not create message: ' + e.message);
            }
        },
        msgBuyCard({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgBuyCard", value: MsgBuyCard.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgBuyCard: Could not create message: ' + e.message);
            }
        },
        msgTransferBoosterPack({ value }) {
            try {
                return { typeUrl: "/DecentralCardGame.cardchain.cardchain.MsgTransferBoosterPack", value: MsgTransferBoosterPack.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgTransferBoosterPack: Could not create message: ' + e.message);
            }
        },
    };
};
export const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new Api({ baseURL: addr });
};
class SDKModule {
    constructor(client) {
        this.registry = [];
        this.query = queryClient({ addr: client.env.apiURL });
        this.updateTX(client);
        this.structure = {
            Card: getStructure(typeCard.fromPartial({})),
            TimeStamp: getStructure(typeTimeStamp.fromPartial({})),
            Collection: getStructure(typeCollection.fromPartial({})),
            CollectionProposal: getStructure(typeCollectionProposal.fromPartial({})),
            CopyrightProposal: getStructure(typeCopyrightProposal.fromPartial({})),
            WrapClearResponse: getStructure(typeWrapClearResponse.fromPartial({})),
            WrapHashResponse: getStructure(typeWrapHashResponse.fromPartial({})),
            Image: getStructure(typeImage.fromPartial({})),
            MatchPlayer: getStructure(typeMatchPlayer.fromPartial({})),
            MatchReporterProposal: getStructure(typeMatchReporterProposal.fromPartial({})),
            Num: getStructure(typeNum.fromPartial({})),
            Params: getStructure(typeParams.fromPartial({})),
            IgnoreMatches: getStructure(typeIgnoreMatches.fromPartial({})),
            IgnoreSellOffers: getStructure(typeIgnoreSellOffers.fromPartial({})),
            QueryQServerResponse: getStructure(typeQueryQServerResponse.fromPartial({})),
            RunningAverage: getStructure(typeRunningAverage.fromPartial({})),
            SingleVote: getStructure(typeSingleVote.fromPartial({})),
            BoosterPack: getStructure(typeBoosterPack.fromPartial({})),
            AirDrops: getStructure(typeAirDrops.fromPartial({})),
            VoteRight: getStructure(typeVoteRight.fromPartial({})),
            VotingResult: getStructure(typeVotingResult.fromPartial({})),
            VotingResults: getStructure(typeVotingResults.fromPartial({})),
        };
        client.on('signer-changed', (signer) => {
            this.updateTX(client);
        });
    }
    updateTX(client) {
        const methods = txClient({
            signer: client.signer,
            addr: client.env.rpcURL,
            prefix: client.env.prefix ?? "cosmos",
        });
        this.tx = methods;
        for (let m in methods) {
            this.tx[m] = methods[m].bind(this.tx);
        }
    }
}
;
const Module = (test) => {
    return {
        module: {
            DecentralCardGameCardchainCardchain: new SDKModule(test)
        },
        registry: msgTypes
    };
};
export default Module;
